# Kubernetes Secret for Bunny API Proxy
# Contains sensitive data: ADMIN_PASSWORD and ENCRYPTION_KEY
#
# !!!!! IMPORTANT SECURITY NOTES !!!!!
#
# 1. This file contains secrets in BASE64 encoding (NOT encryption)
#    - Base64 can be decoded by anyone
#    - This is for storage at rest, not security
#    - Treat this file as sensitive - do NOT commit to git
#
# 2. Kubernetes secrets are stored in etcd without encryption by default
#    - Enable encryption at rest in your Kubernetes cluster
#    - Use kube-apiserver --encryption-provider-config flag
#    - Consider external secret solutions (HashiCorp Vault, AWS Secrets Manager, etc.)
#
# 3. RBAC: Limit who can read secrets
#    - Restrict service account permissions with RBAC policies
#    - Only the bunny-api-proxy pod should access this secret
#
# 4. Secret rotation
#    - Plan for secret rotation procedures
#    - Update secrets and restart pods when keys change
#
# !!!!! CREATION STEPS !!!!!
#
# 1. Generate secure values (do this outside Kubernetes):
#
#    # Generate ADMIN_PASSWORD (32 bytes, base64 encoded)
#    ADMIN_PASSWORD=$(openssl rand -base64 32)
#    echo "ADMIN_PASSWORD: $ADMIN_PASSWORD"
#
#    # Generate ENCRYPTION_KEY (32 bytes, base64 encoded)
#    ENCRYPTION_KEY=$(openssl rand -base64 32)
#    echo "ENCRYPTION_KEY: $ENCRYPTION_KEY"
#
# 2. Create the Secret manifest (replace values below):
#    - Replace ADMIN_PASSWORD_BASE64 with base64-encoded password
#    - Replace ENCRYPTION_KEY_BASE64 with base64-encoded key
#
# 3. Apply to cluster:
#    kubectl apply -f examples/kubernetes/secret.yaml
#
# 4. Verify creation:
#    kubectl get secrets
#    kubectl describe secret bunny-api-proxy-secret
#
# 5. View secret values (requires authorization):
#    kubectl get secret bunny-api-proxy-secret -o yaml
#    # Then manually decode: echo "value" | base64 -d
#
# 6. Rotate secrets (when needed):
#    - Generate new values using commands above
#    - Edit secret: kubectl edit secret bunny-api-proxy-secret
#    - Or delete and recreate: kubectl delete secret bunny-api-proxy-secret
#    - Restart pod: kubectl delete pod <pod-name>
#
# !!!!! ALTERNATIVE: USE EXTERNAL SECRET MANAGER !!!!!
#
# For production, consider:
# - HashiCorp Vault (https://www.vaultproject.io/)
# - AWS Secrets Manager + External Secrets Operator
# - Google Secret Manager
# - Azure Key Vault
#
# Example with External Secrets Operator:
# https://external-secrets.io/
#
# This allows Kubernetes to fetch secrets from external stores at runtime,
# reducing exposure of secrets in your Git repository.

apiVersion: v1
kind: Secret
metadata:
  name: bunny-api-proxy-secret
  namespace: default  # Change to your namespace
  labels:
    app: bunny-api-proxy
  annotations:
    description: "Sensitive configuration for Bunny API Proxy"

type: Opaque  # Generic secret (key-value pairs)

# Base64-encoded secret values
# IMPORTANT: These MUST be base64-encoded, not plaintext
# Base64 is NOT encryption - treat as plaintext
data:
  # ADMIN_PASSWORD - replace with: echo -n "your-password" | base64
  # Example: openssl rand -base64 32 | base64
  admin-password: Y2hhbmdlbWUK  # CHANGE THIS - this is "changeme" base64-encoded

  # ENCRYPTION_KEY - replace with: echo -n "your-key" | base64
  # Example: openssl rand -base64 32 | base64
  encryption-key: Y2hhbmdlbWUK  # CHANGE THIS - this is "changeme" base64-encoded

---
# Example: How to use in Deployment
# See deployment.yaml for the actual usage:
#
# env:
# - name: ADMIN_PASSWORD
#   valueFrom:
#     secretKeyRef:
#       name: bunny-api-proxy-secret
#       key: admin-password
# - name: ENCRYPTION_KEY
#   valueFrom:
#     secretKeyRef:
#       name: bunny-api-proxy-secret
#       key: encryption-key

---
# Example: Create secret from command line
# This approach avoids storing the secret in a YAML file
#
# kubectl create secret generic bunny-api-proxy-secret \
#   --from-literal=admin-password="$(openssl rand -base64 32)" \
#   --from-literal=encryption-key="$(openssl rand -base64 32)" \
#   -n default
#
# Then reference it in the Deployment (see deployment.yaml)

---
# Example: Using stringData (plaintext in YAML, K8s handles base64)
# Less secure but more readable for generation scripts
#
# apiVersion: v1
# kind: Secret
# metadata:
#   name: bunny-api-proxy-secret
#   namespace: default
# type: Opaque
# stringData:
#   admin-password: "your-admin-password"
#   encryption-key: "your-encryption-key"
#
# NEVER commit this to git - generate at deployment time instead

---
# Example: Using External Secrets Operator with Vault
# This prevents secrets from being stored in Git at all
#
# apiVersion: external-secrets.io/v1beta1
# kind: SecretStore
# metadata:
#   name: vault-backend
#   namespace: default
# spec:
#   provider:
#     vault:
#       server: "https://vault.example.com:8200"
#       path: "secret"
#       auth:
#         kubernetes:
#           mountPath: "kubernetes"
#           role: "bunny-api-proxy"
#
# ---
# apiVersion: external-secrets.io/v1beta1
# kind: ExternalSecret
# metadata:
#   name: bunny-api-proxy-secret
#   namespace: default
# spec:
#   refreshInterval: 1h
#   secretStoreRef:
#     name: vault-backend
#     kind: SecretStore
#   target:
#     name: bunny-api-proxy-secret
#     creationPolicy: Owner
#   data:
#   - secretKey: admin-password
#     remoteRef:
#       key: bunny-api-proxy
#       property: admin-password
#   - secretKey: encryption-key
#     remoteRef:
#       key: bunny-api-proxy
#       property: encryption-key
